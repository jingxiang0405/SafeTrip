  import { useBottomTabOverflow } from "@/components/ui/TabBarBackground";
  import { useImage } from "expo-image";
  import { AppleMapsMapType } from "expo-maps/build/apple/AppleMaps.types";
  import { GoogleMapsMapType } from "expo-maps/build/google/GoogleMaps.types";
  import { SafeAreaView } from "react-native-safe-area-context";
  import { locationList } from "@/assets/lib/LocationList";
  import { AppleMaps, GoogleMaps } from 'expo-maps';
  import { Platform, View, Text, Alert, Linking } from 'react-native';
  import { useLocalSearchParams } from 'expo-router';
  import React, { useContext, useEffect ,useState} from 'react';
  import * as Location from 'expo-location';
  //import { fakeBusPositions } from '@/assets/lib/fakeData';
  // import { fakeShapeMap } from '@/assets/lib/fakeShapes';
  import { getMockDependentLocation } from '@/hooks/useMockDependentLocation';
  import busIcon from '@/assets/images/bus.png';
  import stopIcon from '@/assets/images/stop.png';
  import dependentIcon from '@/assets/images/dependent.png';
  import { useProximityAlert } from '@/hooks/useProximityAlert';
  import { GetBusRouteShape , GetBusPos, GetBusAllStops} from '@/utils/busService';
  import { AuthContext } from '@/utils/authContext';

  type StopMarker = { 
    latitude: number;
    longitude: number;
    title: string;
  };

  export default function Map() {
    const authState = useContext(AuthContext);
    const [dependentLocation, setDependentLocation] = useState<{ latitude: number; longitude: number } | null>(null);
    const [shapePoints, setShapePoints] = useState<{ lat: number; lng: number }[]>([]);
    const [busesPos, setBusesPos] = useState<{ latitude: number; longitude: number }[]>([]);
    const [polyline, setPolyline] = useState<{ coordinates: { latitude: number; longitude: number }[] } | undefined>(undefined);
    const [stops, setStops] = useState<StopMarker[]>([]); 
    // ËºâÂÖ•ÂæåÂÆöÊúüÂèñÂæó
    useEffect(() => {
      const interval = setInterval(async () => {
        const loc = await getMockDependentLocation();
        if (loc) setDependentLocation(loc);
      }, 10000); // ÊØè 10 ÁßíÊäì‰∏ÄÊ¨°

      return () => clearInterval(interval);
    }, []);

    //TODO: Áî®ÁúüÁöÑbusPosition
    useProximityAlert(busesPos[0], true);

    useEffect(() => {
      const requestLocationPermissions = async () => {
        try {
          // Request foreground permission first
          const { status: fgStatus } = await Location.requestForegroundPermissionsAsync();
          if (fgStatus !== 'granted') {
            console.log('Foreground location permission denied');
            Alert.alert(
              'ÈúÄË¶Å‰ΩçÁΩÆÊ¨äÈôê',
              'Ë´ãËá≥Á≥ªÁµ±Ë®≠ÂÆö‰∏≠ÈñãÂïü‰ΩçÁΩÆÊ¨äÈôêÔºå‰ª•‰æø‰ΩøÁî®Âú∞ÂúñÂäüËÉΩ',
              [
                { text: 'ÂèñÊ∂à', style: 'cancel' },
                { 
                  text: 'ÂâçÂæÄË®≠ÂÆö', 
                  onPress: () => {
                    if (Platform.OS === 'ios') {
                      Linking.openURL('app-settings:');
                    } else {
                      Linking.openSettings();
                    }
                  }
                }
              ]
            );
            return;
          }

          // Then request background permission
          const { status: bgStatus } = await Location.requestBackgroundPermissionsAsync();
          if (bgStatus === 'granted') {
            console.log('Background location (Always) permission granted');
          } else {
            console.log('Background location (Always) permission denied');
          }
        } catch (e) {
          console.error('Failed to request location permissions:', e);
        }
      };

      requestLocationPermissions();
    }, []);

    const params = useLocalSearchParams();
    const stopsParam = params.stops as string | undefined;
    // TODO: ÊîπÁÇ∫ÂëºÂè´ TDX API ÂèñÂæóË∑ØÁ∑ö shapePointÔºàpolylineÔºâË≥áÊñô
  //   useEffect(() => {
  //     const fetchBusRoute = async () => {
  //       const busRouteShape = await GetBusRouteShape(authState.busNumber ?? '', authState.direction ?? 0);
  //       setShapePoints(busRouteShape ?? []);
  //       // console.log('Bus route shape points:', busRouteShape);
  //     };
  //   fetchBusRoute();
  // }, [authState.busNumber, authState.direction]); 
useEffect(() => {
  const fetchRoute = async () => {
    try {
      const busRouteShape = await GetBusRouteShape(authState.busNumber ?? '', authState.direction ?? 0);
      setShapePoints(busRouteShape ?? []);
      const prepolyline = (busRouteShape).length > 0 ? {
        coordinates: busRouteShape.map((p: { lat: number; lng: number }) => ({
          latitude: p.lat,
          longitude: p.lng,
        })),
        strokeColor: 'blue',
        strokeWidth: 4,
      } : undefined;
      setPolyline(prepolyline);
        const stops = await GetBusAllStops(authState.busNumber ?? '');
        console.log('stopsParam:', stops);
    } catch (error) {
      console.error('Failed to fetch bus route shape:', error);
      setShapePoints([]);
    }
  };

  fetchRoute();
}, []);// üëà this ensures it only runs once
    // TODO: ÊîπÁÇ∫Âæû TDX API ÊãøÂà∞Á´ôÈªûË≥áÊñôÂæåËß£ÊûêÔºå‰∏çË¶ÅÂÜçÂæû URL ÂÇ≥ÂèÉÊï∏Ëß£Êûê  (stopsParam)
    /*const stops = React.useMemo(() => {
      try {
        if (!stopsParam) {  
          return [];
        }
        // Remove any potential wrapping quotes
        const cleanJson = "";//stopsParam(/^"(.*)"$/, '$1');
        const parsed = JSON.parse(cleanJson);
        return Array.isArray(parsed) ? parsed : [];
      } catch (error) {
        console.error('Failed to parse stops:', error);
        console.error('Stops param:', stopsParam);
        return [];
      }
    }, [stopsParam]);*/

    // Default to Taipei city center if no stops available
    const defaultLocation = {
      latitude: 25.0330,  // Taipei 101 location
      longitude: 121.5654
    };

    // Convert stops to map marker coordinates or use empty array
    const stopMarkers: StopMarker[] = stops.length > 0
      ? stops.map((stop: any) => ({
          latitude: stop.StopPosition.PositionLat,
          longitude: stop.StopPosition.PositionLon,
          title: stop.StopName.Zh_tw
        }))
      : [];

    // Set initial region centered on first stop or default location
    const initialRegion = {
      latitude: stopMarkers.length > 0 ? stopMarkers[0].latitude : defaultLocation.latitude,
      longitude: stopMarkers.length > 0 ? stopMarkers[0].longitude : defaultLocation.longitude,
      latitudeDelta: 0.01,
      longitudeDelta: 0.01
    };

    const markersGoogle = [
    ...stopMarkers.map((marker, index) => ({
      coordinates: { latitude: marker.latitude, longitude: marker.longitude },
      title: `${index + 1}. ${marker.title}`,
      snippet : "Á´ôÈªû",
      //icon : busIcon,
    })),
    // TODO: ÂïüÁî® icon Ê¨Ñ‰Ωç‰∏¶ÊîπÁÇ∫ TDX API Êèê‰æõÁöÑÂÖ¨ËªäÂç≥ÊôÇ‰ΩçÁΩÆË≥áÊñô
    // ...(stops.length > 0 ? fakeBusPositions.map((bus, index) => ({
    //   coordinates: bus,
    //   title: `Bus ${index + 1}`,
    //   snippet : "Âç≥ÊôÇ‰ΩçÁΩÆ",
    //   //icon : stopIcon,
    // })) : []),
    ...(dependentLocation
    ? [{
        coordinates: dependentLocation,
        title: 'Ë¢´ÁÖßÈ°ßËÄÖ‰ΩçÁΩÆ',
        snippet : "Àá",
        
      }]
    : [])
    ];
    const markersApple = [
    ...stopMarkers.map((marker, index) => ({
      coordinates: { latitude: marker.latitude, longitude: marker.longitude },
      title: `${index + 1}. ${marker.title}`,
      tintColor: 'deepskyblue',
      systemImage: 'signpost.right',
    })),
    // ...(stops.length > 0 ? fakeBusPositions.map((bus, index) => ({
    //   coordinates: bus,
    //   title: `Bus ${index + 1}`,
    //   tintColor: 'crimson',
    //   systemImage: 'bus',
    // })) : []),
    ...(dependentLocation
    ? [{
      
      coordinates: dependentLocation,
      title: 'Ë¢´ÁÖßÈ°ßËÄÖ‰ΩçÁΩÆ',
      tintColor: 'orange',
      systemImage: 'person.circle.fill',
      }]
    : [])
    ];

    if (Platform.OS === 'ios') {
      return (
        <AppleMaps.View 
          style={{ flex: 1 }}
          cameraPosition={{
            coordinates: {
              latitude: initialRegion.latitude,
              longitude: initialRegion.longitude,
            },
            zoom: 15,
          }}
          polylines={polyline ? [polyline] : []}
          markers={markersApple}
          
        />
      );
    } else if (Platform.OS === 'android') {
      return (
        <GoogleMaps.View
          style={{ flex: 1 }}
          cameraPosition={{
            coordinates: {
              latitude: initialRegion.latitude,
              longitude: initialRegion.longitude,
            },
            zoom: 15,
          }}
          polylines={polyline ? [polyline] : []}
          markers={markersGoogle}
          
        />
      );
    } else {
      return <Text>Maps are only available on Android and iOS</Text>;
    }
  }
